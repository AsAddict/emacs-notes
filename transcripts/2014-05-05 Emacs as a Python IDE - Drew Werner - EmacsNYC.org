#+TITLE: Emacs as a Python IDE - Drew Werner

You can find the video and other details at http://emacsnyc.org/videos.html

#+begin_html
<iframe width="560" height="315" src="//www.youtube.com/embed/6BlTGPsjGJk" frameborder="0" allowfullscreen></iframe>
#+end_html

[[https://s3-us-west-2.amazonaws.com/emacsnyc/videos/emacs-as-a-python-ide.mp4][Download MP4 (349.7 MB)]]

[[https://s3-us-west-2.amazonaws.com/emacsnyc/documents/using-emacs-as-a-python-ide.pdf][slide]]

This transcript is under the Creative Commons Attribution-ShareAlike 4.0 International License.

2014-05-14

https://www.youtube.com/watch?v=6BlTGPsjGJk

https://twitter.com/wernerdrew
https://github.com/wernerandrew



My name is drew, and I'm going to about how to turn emacs into an
intelligent and full-featured ide.

I'm going to be using python as the example for the purpose of this
discussion.

my hope is that some of the techniques I'm talking about, hopefully
you would find some broader application or in other environment. we'll
talk about that a little bit in the end.

anyhow, we going to talk about python and some interesting things to
show you. and I hope you guys find it useful. Thanks for coming out.

so just to give a general sense of what am going to talk about, I'm
going to start out with a little demo, just to show you more or less
what you can hope to have at end, the stuff I talk about.

then I'm going to basically show you how to use it yourself, how to
install the packages, how to customize it to your preferences, and for
those of you who are interested in trying it out yourself without the
pain of changing your existing config, i've created a repository on
github, with a virtual machine.

https://github.com/wernerandrew/jedi-starter

If you guys use vagrant or virtualBox
at all, you can use to try out locally yourselves.

feel free if you want to brave the wifi and try it out as we talk,
otherwise am planning on keeping it up and hopefully will be there is
a resource for you guys to check out, after this talk.

so basically in terms of what you can do in terms of making emacs like
a traditional ide-like environment. There's a few things we gonna talk
today that should be useful on that score. One of them is: being able
to find files and switch between projects easily.

another one is going to be navigating through function definitions and
variable definitions in a way that's sensitive to context, and also
documenting what you see in real-time. If you see a function, or a
variable, being able to see where it came from and what it means.

also, when you have complex function calls or other constructs, it's
nice to be able to have some help for that sort of thing. These are
features that you expect to come along with IDE like Eclipse or
IntelliJ or visual studio. In fact it's possible to get them in emacs.

To start, I'm going to a little demo. Am gonna use my own setup. Here
I'm, in the scratch buffer. Let's say I want to go to a project. I've
taken the liberty of opening some of these files for you but this is
basically how it works.

you can do things like bring up a list of project names. This is a
package called Projectile. It'll let you do that.

Am going to a project called  =vbench= .

http://pydata.github.io/vbench/

as you can see, it has the ability to search interactively. In fact,
it's now highlighted. Am going to switch to that now.

In terms of what file I want to go to, I want to go to a file
called=runner.py=. In fact, typing a few letters gives me that file.
and now here we are.

03:49 so I'm in the file and let's say I want to make a few edits to
something. So just for fun I made a final variable for for largely
throwaway purposes.

We have a this thing called the benchmark DB that we've imported here.
So let's say I want to create a in instances that. So I do DB equals I
was going to type the letter be in right away you can see I have an
auto-complete for this benchmark DB. And I can complete that. And I
can ask what do I need to initialize that.

And I can call something up that just tells me I need path. So
I'm gonna go and do that.

And just for fun I'm gonna call a method on itself I do DB and what do
I see? I see all of the getters defined here. I could use this get
benchmarks function and doesn't take any parameters.

So that's something nice that you can set up. You have a little bit
auto-completion intelligence in your Python.

let's do a little more exploring. So I'm gonna look at the benchmark
in a class and in particular look at the init method.

05:04 I am at the end I've got this thing called the bench repo it
looks pretty complicated. I want to learn a little bit about it. Some
things I can do, I can look at the doc string, with just a key stroke
here, in other buffer. Am gonna zoom in a little bit so you can
convince yourself that is in fact the doc string for it.

05:26 And I can also navigate to its definition.
 So in one key stroke I can see where it is imported from.

And another one I can go to the definition in different file.

This is a great way to navigate quickly. In a way that it respect what
you are investigating, if you're looking at a bug or something like.

So looking at the end of this init function here. Say I wanna check
out the copy_repo command. This auto-completion features also is
intelligent enough to know what class methods look like.

so it jumps to this method that's defined of itself. Let's I want to
look at this to self._prep() function see what's going on there I can
jump is well with single keystroke and now I can look at this run
command thing I can do things like get the function signature, go to
its definition, which is someplace completely different.

06:27 This IDE feature also works not just with the variables and class
defined in your project but also standard library things. For example
here's the subprocess module used here and as you can see you can
bring up a pop-up showing the arguments, or as we saw before bring up
the doc string for it but hopefully you got a good sense that it
actually is in fact what we are looking at.

So now we've gone too far field, how do we get back to start?
Fortunately you can actually just retraced the tree an end up right
back at the original bench repo definition in a few key strokes.

07:06 So hopefully this is done something to show you some of the nice
things about having features like these. You get to, from the comfort
of your emacs environment. Not just know what possible completions
are, get a sense of the documentation, but navigate are much more
quickly than you'd be able to do without this.

07:28 So what he need to make this all happened?

The first part we looked at was the interface involving
auto-completion. It's actually more general than just Python thing.
You need some sort of way showing that pop up box and showing
alternatives, and that's what auto-complete is.

Next you also need a way of parsing the buffers, and that has to be
something that's aware the language you are using.

In fact, the setup runs a small server in the background that wraps a
library that parses the buffers that you're looking at, with some
knowledge of how your system is configured and what your project
environment is.

And where the emacs lisp stuff comes in is really the glue code. These
are a couple packages called epc, jedi.el. Jedi, we'll talk about a
little bit. It is really the brains and how this all works.

epc is a bit of a middleware that connects Python land to emacs land.

We're just gonna … ( that's a artifact from an old version the slide)
hopefully some of you guys have seen before. If not, the syntax is
pretty simple, and in general what I'm gonna talk about is the stuff
that you can just copy and paste into your environment.

we'll go into a bit details talking about how the init file is set up
in the VM.

Speaking of the VM, this is sorta something that I've created to help
you guys try some these features out in your sandbox environment.

So basically you need to be able to run Vagrant and VirtualBox. and
then cloned github repo. Cd into it, bring up the virtual machine.

09:21 The first time you run Vagrant, it'll do all the provisioning
and install the dependencies, and then you can just ssh in.

The initialization code for the virtual machine is =jedi-starter.el=.
in that repository which is a soft linked
 as the .emacs file, from within the virtual machine.

09:44 For those you haven't used vagrant, one the nice things about it
is it allows you to share a directory between your local box and your
virtual machine, so that edits on your local box can be reflected
there. And the basic upshot is that edits to your =jedi-starter.el=
will be reflected in your environment in your virtual machine.

So if you want to do some tweaks or do some experimentation, you can
do that locally in the environment that you're comfortable with, then
try out the results on the VM.

in terms of how this emacs….

10:22 Basically much to the rest of our talk is gonna be talking about
how this file is set up, and by extension how you can set up your own
environment to use some of these features.

so basically the first couple lines in the =jedi-starter.el=
incantation involves including the package function of emacs. We'll
talk about a little more in a second.

10:45 Next, there's some specific code for the package setup that has
to be done to ensure that all the dependencies are installed.

After that there's some global config variables and helper functions
that are defined for reasons that will become clear during the
presentation.

And once that's done, there's some mode specific and package specific
initializations that I've decided to put in this thing called the
after int hook.

I think there's varying schools of thought as to what's the best time
to initialize packages. Your mileage may vary, you might have a
different set up, I found this worked pretty well for my purposes.

The idea being the package setup code ensures that everything is
installed at the time emacs is started, and waiting until that's
completed, allows you to ensure that you are performing initialization
on packages that are in fact installed.

So basically much of this presentation is going to be filling in those
commented lines with actually elisp code that does what you would
expect.

So in terms of the particular I dependencies we're going to use,
there's four that I have in the VM.

12:01 The first is this thing called Projectile. It's quite simple but
I think it's useful and consistent with the idea of sorta turning
emacs to more of an IDE. It basically provides a way of navigating
quickly to your different projects. Assume that you source control,
and navigating quickly within those projects.

Then there's the auto-complete, which we discussed briefly before,
which provides essentially the interface elements that show
completions and inline documentation.

and epc and jedi, which are what makes everything tick, the parts that
are aware of Python managed communications between emacs and the
process that's parsing the buffers.

So for those who have worked with packages before and may be installed
some custom elisp code, it is possible to just do this very basically,
which is to clone these respective repositories and their
dependencies, unzip the tar balls, and add those directories to your
load path and then manually  =require= everything in your .emacs file.

That possible, but we're not going to talk about how to do that today
because its annoying and hard to reproduce.

the strategy i'll say instead involves =package.el=

just to let you know that it is still possible though to install these
things manually…. I have installed manually before, but I saw the
light and started using a package manager. You guys can asked me about
that later you're curious.

Package management comes in standard emacs 24. You have to do a little
bit of work to make it work for emacs 23, if any of you are using
that.

the github repo as sort of a teaching tool uses emacs 23 and you can
look at the setup code particularly… there's basically a elisp file
you have to download and place in the load path, and then everything
else after that it is essentially identical between the version.

14:09 So, the incantation to get it going with the package manager is
pretty simple. You have to =require=  the package, and initialize it,
and then add at least one repository source to it. And the one that
I've chosen here is MELPA, which is one of several options. There is
Marmalade, and then the GNU project has one (ELPA). MELPA I find is
up-to-date with all these packages.

Various anonymous sources on the Internet seem to suggest that it's
pretty well maintained, so why mess with a good thing, I just stick
with that.

One annoying thing is that you do need to remember the trailing
 slash in the URL,

I actually spent some time banging my head again the wall,
failing to include that.

After you you've installed, the packages are stored locally. You can
check them out in your =.emacs.d/elpa/=if you're curious as to
figure out what actually been installed.

15:10 There's two ways to actually get the packages. The one-way which
is not as good is to use 【M-x list packages】, which I'll show you
right now.

So I do that … I get in touch with … here we go. and we get a buffer
that has a bunch of packages. So lets say I navigate, put point over
want these things, I can press the question mark key and see some
documentation for a particular package,

and then I think you press return or maybe you mark or something like
that then it gets installed. You can look at the mode specific help
with 【Ctrl+h m】 for more details on that. I am not gonna spend too
much time on it.

I'll say one useful thing with these packages is it actually shows you
what's builtin and installed already. Here you go, here's the
installed stuff and that can be handy, just to get a sense of what
you've already have in case you're curious.

16:13 So that's the one strategy if you wanna manually handle these
package installations.



Simple auto-installation

#+BEGIN_SRC emacs-lisp
#+END_SRC

(defvar local-packages '(projectile auto-complete epc jedi))
(defun uninstalled-packages (packages)
  (delq nil
        (mapcar (lambda (p)
                  (if (package-installed-p p nil) nil p))
                packages)))
(let ((need-to-install
       (uninstalled-packages local-packages)))
  (when need-to-install
    (progn
      (package-refresh-contents)
      (dolist (p need-to-install)
        (package-install p)))))

16:21 The other one is to use the package.el API, which lets you put
 code in your .emacs file and more easily reproduce package installed
 across environments, just by using the .emacs.

So what he needed to do that? Well I've defined a variable called
 =local-packages=  which just has the names of the packages.

#+BEGIN_SRC emacs-lisp
#+END_SRC

(defvar local-packages '(projectile auto-complete epc jedi))

If you're curious as to the exact name you can always go to (M-x
list-packages) to to learn (the package names). I know at least MELPA
has a website that's search-able, you know Google and all that stuff
also works.

Then I have a little function here that I just kinda happily put
together that given a list to packages it tells you what uninstalled.

I've adapted a little technique If you google “elisp filter Stack
Overflow” will look familiar because emacs built-in doesn't have a
filtering function but what this does is basically allows you to using
the package installed key command, which basically tells you whether
packages installed, just returns a list only the uninstall packages.

And then given that list, I have some code that binds it to a
temporary variable called  =need-to-install= , and when that variable is
non-nil, I refresh the content of the local package manager, and then
for each uninstall package I call the function  =package-install-p=
with that's the name. So that the command that does the magic package
install.

So now you have your package installed and what remains is just to
enable them.



Working with Projectile

• I Some helpful commands:

C-c p s Switch to project
C-c p f List files in project
C-c p k Kill all buffers for project

More info: https://github.com/bbatsov/projectile

18:14 So I'm gona take the easy ones first, the first one is
Projectile, which is a package that allows you to navigate between
projects.

So what it does…
three commands I have up there are about 99 percent of what I use with it.

There's other stuff online that the more sophisticated types among you
might find interesting, but I find this is more than adequate for my
purposes.

I what it does is it remembers different projects that you navigate
to, by basically what repository they are in. So you navigate to a
file in particular git repository and it'll remember that make it
searchable via the switch to project command. which I showed you
earlier, and then you can interactively search within that project for
different files.

And then when you're all done kill all buffers with a given project which is
particularly helpful.

You know when you get to a point where you have three different projects open,
20 buffers each, its kinda nice to have that.

and it's a very nice, very easy to use, documentation. You can look
online for a very thorough Read Me file. This bbatsov gentlemen I
think he also does the emacs Prelude, if any guys are into that, and
and he is a Prelude user, I think Projectile comes standard with that.

If you really want to get up in going with that,

Easy setup:

#+BEGIN_SRC emacs-lisp
(require 'projectile)
(projectile-global-mode)
#+END_SRC

19:39 those are the only two commands you actually need to to use.

I have a couple customization because I like my results displayed
vertically. those are not specific for Projectile but to something
called ido-mode.

but in interest of keeping things simple, that will get you started
and there's a lot resources online for additional customization
you can do with it.

One other note: for some reason the most recent version of Projectile
relied on this  =remote-file-name-inhibit-cache= , which does not
appear to be included in a vanilla emacs 23 install, at least it
wasn't on my VM, which was just an  =apt-get install emacs=  from Ubuntu.

#+BEGIN_SRC emacs-lisp
;; Emacs 23 hack
(when (not (boundp 'remote-file-name-inhibit-cache))
  (setq remote-file-name-inhibit-cache t))
#+END_SRC

So I have this little hack to bind the variable to a safe value which
in this case is true. For those of you … I forget if we talked about
this last month … =bound-p= function, which given a symbol, it tells
you whether it exists, whether that variable exists. And so when it
doesn't, it set it to something safe, so, that lets you use with emacs
23.



Package Config
auto-complete is also easy:

#+BEGIN_SRC emacs-lisp
(require 'auto-complete-config)
(ac-config-default)
;; If you really like the menu
(setq ac-show-menu-immediately-on-auto-complete t)
#+END_SRC

• Automatically integrates with most common programming
modes
• But only enables basic completions
• Language-specic keywords
• Words in buffers with same mode
• Doesn't know anything about syntax

20:52 Next up is auto-complete. Also pretty easy if you are just want
to use the default values. that is it.

#+BEGIN_SRC emacs-lisp
(require 'auto-complete-config)
(ac-config-default)
#+END_SRC

What does the default configuration get you? It does get you something.

#+BEGIN_SRC emacs-lisp
(setq ac-show-menu-immediately-on-auto-complete t)
#+END_SRC

ok one other thing I showed you guys, showed the menu essentially right
away. If you like that, I sorta like that, there's a vividly named variable
that you can set to true, and it does about what it sounds like which
is to show the menu immediately on auto-complete.

and what is it… in terms of being active… generally for most the
common programming mode c-mode and the like, it will be active
automatically but the only completions you'll have is kinda basic.

the the dome? in less useful long are the language-specific keywords
in case like you really wanna have while auto-complete save those
extra three key strokes after the WH that is an option for you but the
other thing it does is like collect all the words in buffers with the
same mode into automatically make this available to you. the thing is
though it doesn't know anything about syntax. It can tell you anything
about the appropriateness or the meaning of those completions.

Which is why the auto-complete really can be improved upon.

the nice thing though is that auto-complete does have an interface for
third party packages to provide completions to it, and that's what
jedi does in essence, among other things.

Jedi: The Brains

Several things have to play nicely for this all to work:
• Jedi
 •  A Python library for contextual parsing of ﬁles
 •  Not speciﬁc to Emacs
 •  https://github.com/davidhalter/jedi
• EPC
 • Simple Emacs/Python RPC library

22:29 so we've talked enough about jedi and and that's really the
centerpiece of this whole operation, and its the most annoying and
difficult thing to configure.

This is because there are a few different components to Jedi. first of
all, you have the Jedi Python library, which does the actual work of
parsing, and it provides a nice and pretty pretty well abstracted
interface, where you can give it a whole blob of text and position
within that file and it'll tell you things about the context of
whatever variable you're looking, or your point is.

its actually not originally for emacs, I believe it was originally
developed for the vim community, but we are still been able to
reappropriate for our own purposes. You can see more details online,
if you're really interested in the internals. You don't actually have
to know all that much about it to set it up.

And then there's this piece of middleware, which is kind of an odd duck
EPC.

You know it's a dependency, it's not used all that much, but it
basically works is the glue and it's worth remembering something needs
to be installed.

23:38 It has both a python package associated with it as well as a
small elisp package because it does have to talk between both
environments.

And then Jedi.el is the interface that's the elisp froentend as well
as a very small Python server that talks through EPC to Jedi. This is
really what you customize and what you set up. and and and really
provides the interface for working with all this to emacs.

so here's a diagram, kinda showing the flow just because there's a few
component to work together, so your pipe stuff in or tell Jedi you
want to do something or go somewhere, Jedi will turn that into a
python function call that will be parsed and send through by the Jedi
library and then the relevant information will be sent back to the
jedi elisp library and presented appropriately in the form of
completions or like someplace for you to jump to during navigation.

so there's some Python dependencies on this and you have two choices,
one good and one adequate, in terms of how to deal with this.

The better option if it's available to you is to let Jedi handle it.

you need two things for this to work. One is  =pip= , which most people I think if
you working with Python it's become increasingly popular tool for managing
packages.

It's basically you know the simplest way to install a package and dependencies.

25:08 The other one is virtualenv… for those of you … it would be
roughly analogous to like RVM. for those are you from Ruby backgrounds
and lets you manage different Python versions on two different sets of
packages and switch between them. Using some up basic shell commands.

25:38 What this allows you do when you have those things installed as
you can just issue a one-time command from emacs, every time you
deploy your set up on a new machine, and you'll get all your
dependencies in a sandbox environment.

The downside is if you use for example other package managers and the
one that's from my own experience on my personal boxes is conda, which
if you use the continuum.io and conda distribution, It doesn't play
too well virtualenv. So if you can't use that virtualenv, you're left to
do it yourself.

Which means that you have to do a pip install epc
pip install epc Jedi globally,

you have to be sure when you start emacs that those modules are in a
place where they can be found, that may involve pointing jedi during
startup to a particular installed python.

I'm going to discuss a quick function for doing that as a sidebar
later on but just F.Y.I that's why I mention it.

The bare minimum:

#+BEGIN_SRC emacs-lisp
(require 'jedi)
;; Hook up to autocomplete
(add-to-list 'ac-sources 'ac-source-jedi-direct)
;; Enable for python-mode
(add-hook 'python-mode-hook 'jedi:setup)
#+END_SRC

26:42 The absolute minimum to hook up jedi is also pretty simple.
You import a library and then as I was talking about
auto-complete is extensible with different sources and that's what the
 =(add-to-list ac-sources …)=  command does, it gives you,
 exposes a source called  =ac-source-jedi-direct=
on you that.

And then the next thing you should do should add to the
 =python-mode-hook=  the  ='jedi:setup=  function so many you may
already know about hook's of hook are basically emacs way I love
letting you you know add functionality dynamically at certain times in
emacs is life cycle and the  =python-mode-hook=  for example but is
called when you're entering  =python-mode=  for a given but for and by
adding a function in that hook you can ensure that that function is
called as an initialization step.

The other interesting thing about the  =add-hook= function is that it
actually adds element I believe to the beginning of the list.

and so we actually want to add jedi set up first to the
 =python-mode-hook=  in our init file and this actually becomes
important because we're gonna add some customization to Jedi variables
that are specific to a given buffer that need to be made before jedi
setup is called.

so this is done in the virtual machine but if you're experimenting in your local environment keep in mind that there has to be called first and therefore added first up the Jedi functions to the Python mode hood.

28:08 now the bare minimum gets you some of the auto-complete function
but it'll only get you the standard library, which is is nice but some
of the most valuable stuff in jedi comes from being able to navigate
between files in a given project, and you are only get a relatively
trivial version of that, you'll actually only get files in the same
directory, in certain cases.

You can improve on that by configuring the jedi server before it
starts up.

this is actually done by setting in emacs variable that allows you to
set the Jedi server args.

The two args that are worth thinking about are the  =system-path= ,
for those of you who use Python.  =sys.path=  is where Python looks
for modules.

And if you want to specify a virtual environment that is not the
currently active virtual environment you can also do that via the
virtual and switches well. ( =--virtual-env= )

if you are in a given buffer and you wanna see what arguments are
active, this can be useful when when you're setting something up and
trying to debug it.

29:23 you can do it by on emacs by  =describe-variable= facility. That
can be done by either by  =describ-variable=  or 【control+h v】.

I'll type jedi server-args and I get a bunch information in the help buffer,
I can see the current value is is equal to the project root. and
the global value is  =nil= , more on that in a second.

now that  =sys-path=  valued didn't just set itself, we had to do
something for that to be set correctly.

and same with the virtualenv variable. I've set that to  =nil=  I
think most you'll probably also you know not need to use that.

Basically I to configure both for those. this is kinda the setup that
I have in the virtual machine

#+BEGIN_SRC emacs-lisp
(defvar jedi-config:with-virtualenv nil
"Set to non-nil to point to a particular virtualenv.")
#+END_SRC

30:20 I have the with virtual and variable either nil or a string that
gives a path to particular virtualenv, and but the more complicated
stuff is related to finding the project root.

#+BEGIN_SRC emacs-lisp
;; Variables to help find the project root
(defvar jedi-config:vcs-root-sentinel ".git")
(defvar jedi-config:python-module-sentinel "__init__.py")
#+END_SRC

so I define two variables and again lots different approaches you can
 use.

one is a particular sentinel to use in terms of finding a repository
 I just chosen  =".git"= .

What I what I mean by “sentinel”? I mean that's a file that you'd
expect to see in the base directory of a repository. Am sure your git
repository will have a .git directory in its root directory. Emacs has
facilities for being able to find that.

31:08 Similarly there's this thing called the  =python-module-sentinal=

#+BEGIN_SRC emacs-lisp
(defvar jedi-config:python-module-sentinel "__init__.py")
#+END_SRC

the simplified example I show you here that doesn't actually rely on it. The more complicated example in the VM does.

for those of you who don't use Python,  =__init__.py=  is a file that has to exist in certain directories for modules to be importable.

31:32 and the location of  =__init__.py=  file can also be helpful
information and in terms a understanding what the base directory for a
given buffer is, like, where is the base directory relative to a given
project. It's not always the version control root base and so knowing
how to find that in it that init.py file can be a helpful technique
and that's that we do online.

so a basic function that gets the project root file might look
something like this:

#+BEGIN_SRC emacs-lisp
;; Function to find project root given a buffer
(defun get-project-root (buf repo-type init-file)
(vc-find-root (expand-file-name (buffer-file-name buf)) repo-type))
#+END_SRC

32:05 again this is a simple elisp function. I've used  =defun= to
define a function that I've called  =get-project-root= that takes
three arguments: the buffer, the repository type, and the init file.
The third argument is just so I can define multiple functions with
compatible signatures.

again the more complicated version of this function does use the init
file variable.

so what does this do?

well I'm actually gonna show you by working out from the scratch buffer.

so we go to scratch, and if we type (get-buffer "runner.py") I'm gonna do runner.py. I'm gonna switch to the messages real quick. so we go to (get-buffer "runner.py")

33:05 we see a that it evaluates to a variable that stands for
the buffer.

now there's a function called  =buffer-file-name=
which tells us the file corresponding to that buffer.

In this case there is a file and it's non-nil.

33:23 so now if we want to do, I do probably as a belt-and-suspenders
thing, I use this  =expand-file-name=  function to turn into absolute
path in this case that's not strictly necessary because it has the
correct value by default.

then lastly we have =vc-find-root=  which is actually a built-in emacs
function that given a version control signifier it will tell you what
the base directory is for that particular repository.

so here we've used .git because this is a git repository
and sure enough we have the
 =~/Documents/Work/vm/vbench/=
which is what we're looking for.

so this is basically what this function does.

34:20 And then we define a variable

#+BEGIN_SRC emacs-lisp
(defvar jedi-config:find-root-function 'get-project-root)
#+END_SRC

that that uses that function as a symbol to indicate what should be
done to identify the project root buffer.

and then after that configurable set, we have this function
 =current-buffer-project-root=

#+BEGIN_SRC emacs-lisp
;; And call this on initialization
(defun current-buffer-project-root ()
  (funcall jedi-config:find-root-function
           (current-buffer)
           jedi-config:vcs-root-sentinel
           jedi-config:python-module-sentinel))
#+END_SRC

34:43 that calls the function in question. it uses the current buffer
function to find the current buffer, unsurprisingly enough and then
the configs variables, so that it looks for the correct repository
type and the  =python-module-sentinel= .

and I have a fancier version online if you want to take a look on that
but the this will do the trick at least to get us started.

and now it's left to set the server arguments.
 so I have a little macro that
just adds 2 elements to the end to the list.

If you gets really curious we would go to more detail later but it's
just a simple little helper function to make the rest a little bit
more readable.

and then I use my current-buffer-project-root file to define a
variable called Project root in the context of this Jedi've configs
set up server-arg function

• A list: (ARG1 VALUE1 ARG2 VALUE2 ...)
• Store in buﬀer local variable jedi:server-args

#+BEGIN_SRC emacs-lisp
(defun jedi-config:setup-server-args ()
       ;; little helper macro
       (defmacro add-args (arg-list arg-name arg-value)
         ‘(setq ,arg-list (append ,arg-list (list ,arg-name ,arg-value))))
       (let ((project-root (current-buffer-project-root)))
         ;; Variable for this buffer only
         (make-local-variable 'jedi:server-args)

         ;; And set our variables
         (when project-root
           (add-args jedi:server-args "--sys-path" project-root))
         (when jedi-config:with-virtualenv
               (add-args jedi:server-args "--virtual-env"
                         jedi-config:with-virtualenv))))
#+END_SRC

35:43 and the next command is called  =make-local-variable=  that's
that's an interesting command that allows you to make a variable that
is local only to the buffer in which that that functions called.

and that is helpful when you have a situation where you have multiple
projects that might be using Jedi and you wants to be able to set the
Jedi  =server-args=  variables to different values depending on what
buffer you are in.

So the  =make-local-variable=  call is actually quite important and
add considerably to the flexibility you have in terms of creating
multiple environments and using them the same emacs session.

and then we set up variables.

#+BEGIN_SRC emacs-lisp
         ;; And set our variables
         (when project-root
           (add-args jedi:server-args "--sys-path" project-root))
         (when jedi-config:with-virtualenv
               (add-args jedi:server-args "--virtual-env"
                         jedi-config:with-virtualenv))
#+END_SRC

36:23 both of these are just condition on a  =project-root=  being
defined and the config variables for virtualenv being defined.

and hopefully that's self explanatory enough that adds the appropriate
arguments to the Jedi server args variable and the idea being that the
argument and then the value follow each other.

Sidebar: Finding Python

If you can't use virtualenv, you might need to explicitly select a
Python to run.

Also, on Mac OS X (and perhaps other GUI environments), your
PATH may need to be set explicitly.

#+BEGIN_SRC emacs-lisp
(defvar jedi-config:use-system-python t)
(defun jedi-config:set-python-executable ()
       (set-exec-path-from-shell-PATH) ;; for OS X
       (make-local-variable 'jedi:server-command)
       (set 'jedi:server-command
             (list (executable-find "python")
                   (cadr default-jedi-server-command))))
#+END_SRC

36:49 from there, the sidebar that I mentioned before is one other command

that you might find you need to use which is to find the correct
python when you can't use virtualenv and I won't spend too much
time in this because this is a bit of a corner case but I have this
switched on and off by this =jedi-config:use-system-python= config
variable and it has a couple things.

first of all it's the  =jedi-config:set-python-executable=  function
for Mac OS X you actually need to use this function that defined in
the =__init__.py= file that basically takes the path of environment
variable from the shell and makes it available to emacs. Again its a
corner case, more details are online.

and if you google that you'll get a helpful Stack Overflow answer that
will tell you much of what you need to know.

and then you make your own local variable gain this time it's called
 =jedi:server-command=

37:53 and then in this case you set the first value of
 =jedi:server-command=  . You could probably do this with a  =setcar=
too.

To a value given by  =(executable-find "python")= .

Just to illustrate what that looks like, [demo in emacs *scratch
buffer*] ( I get which is you can see the bottom line here is my
particular python which as I mentioned before happens to be that which
is installed by anaconda.)

so again for those of you are having issues starting up jedi server
you may use something like this in your environment.

38:40 and now we had the hook functions we define before.

Putting everything together

#+BEGIN_SRC emacs-lisp
(add-hook 'python-mode-hook
           'jedi-config:setup-server-args)
(when jedi-config:use-system-python
      (add-hook 'python-mode-hook
                 'jedi-config:set-python-executable))
#+END_SRC

we set up a server args first and then we set the executable.

when its its the the  =use-system-python=  variable true (or non-nil).

and then I have a couple suggested keybinding. the functions I showed you before when navigating are basically these four:

jedi:goto-definition
Move to deﬁnition of symbol at point
default: C-c .
suggested: M-.

39:00 to jump, you use the the the  =jedi:goto-definition=
which is great for quickly navigating.

jedi:goto-definition-pop-marker
Move to previous location of point
default: C-c ,
suggested: M-,

the  =jedi:goto-definition-pop-marker=  command takes you back on to
where you were before that's how we got very quickly back to where we
started when we did our little navigation to the project.

jedi:show-doc
Show docstring for symbol at point in new window
default: C-c ?
suggested: M-?

on and then the  =jedi:show-doc=   command about what you think.
it just show the doc string and in a special buffer.

and then this  =jedi:get-in-function-call=  thing

jedi:get-in-function-call
Pop up signature for function at point
default: None
suggested: M-/

that's what pops up the function signature when you're between
parentheses for a function call and I find that handy sometimes It's
actually not bound by the fault.

this is my set up keys again,

Local Jedi keybindings

#+BEGIN_SRC emacs-lisp
(defun jedi-config:setup-keys ()
       (local-set-key (kbd "M-.") 'jedi:goto-definition)
       (local-set-key (kbd "M-,") 'jedi:goto-definition-pop-marker)
       (local-set-key (kbd "M-?") 'jedi:show-doc)
       (local-set-key (kbd "M-/") 'jedi:get-in-function-call))
(add-hook 'python-mode-hook 'jedi-config:setup-keys)
#+END_SRC

 =local-set-key=  just to mention that.
that sets a key for a particular buffer if you don't want to clobber
global settings for other modes.

and there's a little hack

Jedi Miscellany
• Small hack to never show in-function call automatically:
 • (setq jedi:get-in-function-call-delay 10000000)
 • Recommended if you bind this to a key

because by default the get-in-function-call always pops up the getting
function call after certain delay I have set that delay a variable
which is a in milliseconds to an absurdly large value and I would
recommend that if you use the key binding I suggested you do something
like this yourself. And in fact that's done in the VM.

and one little tweak that I kind of like is is the complete on dot

• Complete when you type a dot:
 • (setq jedi:complete-on-dot t)
 • Useful when typing method callsOther Packages

 which is that for example, when you… I get the completions showing up
 automatically right on the dot. That can be useful sometimes if you
 want to see a completion right upon a method call.

40:53 I okay so that's basically it for Jedi set up. Like I said this
general paradigm does imply to other languages, and the basic idea
that the common problem that has to be solved for all of them is
telling whatever process is learning about your code where everything
is, so some other things such as finding the project root, and
other things can be helpful for that. and they also will generally
follow a pattern where they will provide some way of connecting to a
back-end, or connecting to auto-complete or similar interface, and I think
that's true for all of these.

one thing i'll mention on top of auto-complete is there something
called company-mode. I don't believe jedi has a a connection for that
as well, but that's something a lot of people use as an alternative.

so that basically concludes the talk, so thank you guys for your
attention.

AUDIENCE: [APPLAUSE]

Do we have time for any questions? any questions from the audience?

AUDIENCE: I guess the answer's no but […]

42:17 I haven't tried it, what I don't know … I don't know if … I
think the problem is that when you start the Jedi server you have to …
yeah yeah I think you have to give something that's like… address,
like that that's a path in the sense that your system would
understand because it's a separate Python process that has to access
others libraries. I think the same goes also for like if you like in a
virtual machine or something like that, so I think the answer is no, I
think you're correct

AUDIENCE: relative to … [inaudible]

42:54 by default it will have the same sys path as starting Python and
the current directory would, so I believe… actual am sure

AUDIENCE: [inaudible]

I haven't tried that I suspect no, because is how much else is going on but certainly worth a try.

AUDIENCE: [inaudible]

43:43 emacs 23? emacs 24? I haven't noticed except that when I've
installed packages recently I need fewer hacks to make them work with
emacs 24.

there's some other stuff too but none are coming off the top my head,
I've been using 24 I'm quite happy.

AUDIENCE: different virtualenv … how to determine which virtualenv to use … [inaudible]

I've thought a little bit about that I mean the solution I have in the
VM … I did not having time to come up with an intelligent way of doing
that is because that's not part of my own workflow

you have to figure out basically some way of given a buffer's location
and its parent repository, what virtualenv is that mapped to … there
could be a couple things… you can have a convention about having a
particular file … that tells you what virtualenv that is, or you can
have a way to find and therefore set that variable. So you have to do
something like that, it's certainly possible but probably would be
more of a question of how you organize your project at this point.

AUDIENCE: sentinel turned on … so start … if I see … some directory … [inaudible]

45:26 I believe it does a slightly more robust version of the vc-find
and I think it keeps a list of like you know SVN CVS git so forth and
then it will infer that it's a repository and navigate to the buffer.

AUDIENCE: that directory … project, start switch between … [inaudible]

45:46 that's correct, yes.

AUDIENCE: show us … vertical layout? … [inaudible]

45:57 sure, if you guys want I can show you real quick, mine my own
.emacs. Just a one second. And so this is actually, I took this from
emacs wiki, which is a great resource, it is basically this part here
[highlighted] where…

AUDIENCE: [inaudible]

if there is then I would recommend looking into, cuz…

AUDIENCE: list-packages … [inaudible]

46:54 its  =ido-vertical-mode= . there you go

so simple package simple simple documentation.

okay so I take back what I said before I recommend that you use this thing that
I've never used that sounds much better.

anybody else?

okay I thank you all so much for your time, really appreciated.
